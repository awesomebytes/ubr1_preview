UBR-1 Standard Interfaces
=========================

The UBR-1 uses most of the standard ROS interfaces for interacting
with user code. This should make it easy to port code previously
written for the PR2 or other platforms to the UBR-1.

Standard inteferaces are defined by two key characteristics -- the
standard ROS message or action definition, which defines the messages
used, and the namespace in which the drivers subscribe to incoming
messages or expose the action interface. In each description below, we
mention both the message or action type as well as the namespace we
use.

Arm and Torso Interfaces
------------------------

The robot arm and torso can be controlled through a standard
FollowJointTrajectoryAction. This action allows the robot to accept a
pre-defined trajectory, such as those generated by packages like
MoveIt! There are three joint trajectory actions available, for the
use cases of arm alone, torso alone, and arm + torso at the same time:

``arm_controller/follow_joint_trajectory`` (`control_msgs/FollowJointTrajectory <http://docs.ros.org/api/control_msgs/html/action/FollowJointTrajectory.html>`_)
  This action interface allows control of the seven joints of the arm. See the script "move_my_arm.py" in the ubr1_demo package.


``arm_with_torso_controller/follow_joint_trajectory`` (`control_msgs/FollowJointTrajectory <http://docs.ros.org/api/control_msgs/html/action/FollowJointTrajectory.html>`_)
  This action interface allows control of the seven joints of the arm and the torso lift joint at the same time.

``torso_controlller/follow_joint_trajectory`` (`control_msgs/FollowJointTrajectory <http://docs.ros.org/api/control_msgs/html/action/FollowJointTrajectory.html>`_)
  This action interface allows control of the single joint of the torso lift.

More advanced controllers, such as Cartesian pose and wrench controllers,
will be available in the actual robot release, but are not included in this preview.

Gripper Interface
-----------------

On the real UBR-1, the gripper is a modularity point and can be
swapped out. The simulator only simulates the default gripper at this
time. The default gripper uses a standard "control_msgs/GripperAction"
action interface. This is in the namespace "gripper_controller". Details:

``gripper_controller/gripper_action`` (`control_msgs/GripperCommand <http://docs.ros.org/api/control_msgs/html/action/GripperCommand.html>`_)
  This action interface allows control of the gripper opening.

Head Interfaces
---------------

Similarly, the robot head can be controlled in several ways. As with
the arm, a joint trajectory can be sent through an action-based
interface In addition, the head has a "point head" interface that can
focus the sensor on a point of interest. Details:

``head_controller/follow_joint_trajectory`` (`control_msgs/FollowJointTrajectory <http://docs.ros.org/api/control_msgs/html/action/FollowJointTrajectory.html>`_)
  This action interface allows control of the head pan and tilt by a pre-defined trajectory.

``head_controller/point_head`` (`control_msgs/PointHead <http://docs.ros.org/api/control_msgs/html/action/PointHead.html>`_)
  This action interface allows the pointing of the head sensor at a point of interest.

Base Interface
--------------

The UBR-1 mobile base is commanded using the standard ROS interface
for mobile bases by publishing a msg as apposed to an action goal.
For more information about the UBR-1 ``base_controller`` see the :ref:`ubr_controllers Node API`.

``base_controller/command`` (`geometry_msgs/Twist <http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html>`_) 
  This message interface allows the UBR-1 to interact with standard software packages in ROS like the Navigation stack.

